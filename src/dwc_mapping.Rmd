---
title: "Darwin Core mapping"
subtitle: "For: Checklist of alien species of the Scheldt estuary"
author:
- Lien Reyserhove
- Sanne Govaert
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
#  pdf_document:
#    df_print: kable
#    number_sections: yes
#    toc: yes
#    toc_depth: 3
---

This document describes how we map the checklist data to Darwin Core. The source file for this document can be found [here](https://github.com/trias-project/alien-scheldt-checklist/blob/master/src/dwc_mapping.Rmd).

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = TRUE)
```

Load libraries:

```{r message = FALSE}
library(tidyverse)      # To do data science
library(magrittr)       # To use %<>% pipes
library(here)           # To find files
library(janitor)        # To clean input data
library(digest)         # To generate hashes
library(rgbif)          # To lookup names in the GBIF backbone taxonomy
library(inborutils)     # To wrap GBIF API data
```

# Read source data

The data is maintained in [this Google Spreadsheet](https://docs.google.com/spreadsheets/d/1LeXXbry2ArK2rngsmFjz_xErwE1KwQ8ujtvHNmTVA6E/edit#gid=510059691).

Read the relevant worksheet (published as csv):

```{r}
raw_data <- read_csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vTl8IEk2fProQorMu5xKQPdMXl3OQp-c0f6eBXitv0BiVFZ3JSJCde0PtbFXuETgguf6vK8b43FDX1C/pub?gid=541627250&single=true&output=csv", show_col_types = FALSE)
```

Copy the source data to the repository to keep track of changes:

```{r}
write.csv(raw_data, here::here("data", "raw", "alien_scheldt_dump.csv"), row.names = FALSE)
```

# Preprocessing: tidy data and add taxon ID's

To link taxa with information in the extension(s), each taxon needs a unique and relatively stable `taxonID`. We have created one in the form of `dataset_shortname:taxon:hash`, where `hash` is unique code based on scientific name and kingdom. Once this is created, it is added to the source data. 

```{r}
input_data <-
  raw_data %>%
  remove_empty("rows") %>%
  clean_names() %>%
  mutate(
    taxon_id = paste(
      "alien-scheldt-checklist",
      "taxon",
      .data$taxon_id_hash,
      sep = ":"
    )
  )
```

# Darwin Core mapping

## Taxon core

Create a dataframe with unique taxa only (ignoring multiple distribution rows). Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).

```{r}
taxon <-
  input_data %>%
  distinct(taxon_id, .keep_all = TRUE) %>%
  mutate(
    language = "en",
    license = "http://creativecommons.org/publicdomain/zero/1.0/",
    rightsHolder = "INBO",
    accessRights = "https://www.inbo.be/en/norms-data-use",
    datasetID = "",
    institutionCode = "INBO",
    datasetName = "Checklist of alien species in the Scheldt estuary in Flanders, Belgium",
    taxonID = taxon_id,
    scientificName = scientific_name,
    kingdom = kingdom,
    phylum = phylum,
    class = class,
    order = order,
    family = family,
    genus = genus,
    taxonRank = taxon_rank,
    nomenclaturalCode = nomenclatural_code,
    .keep = "none"
  ) %>% 
  arrange(taxonID) %>% 
  select(
    "language", "license", "rightsHolder", "accessRights", "datasetID",
    "institutionCode", "datasetName", "taxonID", "scientificName", "kingdom", 
    "phylum", "class", "order", "family", "genus", "taxonRank",
    "nomenclaturalCode"
  )
```

## Distribution extension

Create a dataframe with all data (including multiple distributions). Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

Information for `eventDate` is contained in `date_first_observation` and `date_last_observation`, which we will express here in an ISO 8601 date format `yyyy/yyyy` (`start_date/end_date`).

Not all cells for `date_first_observation` (DFO) and/or `date_last_observation` (DLO) are populated. So, we used the following rules for those records: 

***case 1.*** If `DFO` is empty and `DLO` is empty, `eventDate` is `NA` 
***case 2.***  If `DFO` is empty and `DLO` is not empty: eventDate = `/DLO`
***case 3.*** If `DFO` is not empty and `DLO` is empty, eventDate is `DFO/`

```{r}
distribution <-
  input_data %>%
  # # pathway
  # pivot_longer(
  #   names_to = "key",
  #   values_to = "pathway",
  #   starts_with("introduction_pathway"),
  #   values_drop_na = FALSE) %>%
  # filter( # keep NA value for species with no pathway provided
  #   !is.na(pathway) |
  #     (is.na(pathway) & key == "introduction_pathway_1")
  #   ) %>%
  # other terms
  mutate(
    taxonID = taxon_id,
    locationID = case_when(
      location == "Flanders" ~ "ISO_3166-2:BE-VLG",
      location == "Wallonia" ~ "ISO_3166-2:BE-WAL",
      location == "Brussels" ~ "ISO_3166-2:BE-BRU"
    ),
    locality = case_when(
      location == "Flanders" ~ "Flemish Region",
      location == "Wallonia" ~ "Walloon Region",
      location == "Brussels" ~ "Brussels-Capital Region"
    ),
    countryCode = country_code,
    occurrenceStatus = occurrence_status,
    establishmentMeans = establishment_means,
    # degreeOfEstablishment = degree_of_establishment,
    eventDate = case_when(
      is.na(date_first_observation) & is.na(date_last_observation) ~ NA,
      is.na(date_first_observation) ~ paste0("/", date_last_observation),
      is.na(date_last_observation) ~ paste0(date_first_observation, "/"),
      !is.na(date_first_observation) & !is.na(date_last_observation) ~ 
        paste(date_first_observation, date_last_observation, sep = "/")
    ),
    source = source,
    occurrenceRemarks = occurrence_remarks
  ) %>%
  select(
    "taxonID", "locationID", "locality", "countryCode", "occurrenceStatus",
    "establishmentMeans", # "degreeOfEstablishment", "pathway", 
    "eventDate", "occurrenceRemarks", "source" 
  ) %>%
  arrange(taxonID)
```

## Create species profile extension

In this extension will express broad habitat characteristics (e.g. `isTerrestrial`) of the species.

```{r start_species_profile}
species_profile <- input_data
```

Habitat information can be found in `realm`, which describes whether a species is found in freshwater, terrestrial or both (terrestrial/freshwater) habitats.

Show unique values:

```{r}
species_profile %>%
  group_by(realm) %>%
  count()
```

We map this information to `isFreshwater` and `isMarine` in the [Species Profile](http://rs.gbif.org/extension/gbif/1.0/speciesprofile.xml):

### taxonID

```{r}
species_profile %<>% mutate(dwc_taxonID = taxon_id)
```

### isMarine

```{r}
species_profile %<>% mutate(dwc_isMarine = "TRUE")
```

### isFreshwater

```{r}
species_profile %<>% mutate(dwc_isFreshwater = "TRUE")
```

### isTerrestrial

```{r}
species_profile %<>% mutate(dwc_isTerrestrial = "FALSE")
```

Show mapped values:

```{r}
species_profile %>%
  select(realm, dwc_isMarine, dwc_isFreshwater, dwc_isTerrestrial) %>%
  group_by_all() %>%
  summarize(records = n())
```


## Create description extension

In the description extension we want to include several important characteristics (hereafter refered to as descriptors) about the species:

* Native range
* Introduction pathway
* Degree of establishment

The structure of the description extension is slightly different from the other core/extension files: information for a specific taxon (linked to taxonID) is provided in **multiple** lines within the csv file: one line per taxon per descriptor. In this way, we are able to include multipele descriptors for each species. 

For each descriptor, we create a separate dataframe to process the specific information. We always specify *which descriptor* we map (`type` column) and its *specific content* (`description` column). After the mapping of these Darwin Core terms `type` and `value`, we merge the dataframes to generate one single description extension. We then continue the mapping process by adding the other Darwin Core terms (which content is independent of the type of descriptor, such as `language`).

### Native range

Create separate dataframe:

```{r start_native_range}
native_range <- input_data
```

Show unique values:

```{r}
native_range %>%
  distinct(native_range) %>%
  arrange(native_range)
```

`native_range` contains multiple values (currently not more than 3), so we separate it in 3 columns:

```{r}
native_range %<>% separate(native_range, 
  into = c("native_range_1", "native_range_2", "native_range_3"),
  sep = "\\s\\|\\s",
  remove = FALSE)
```

Gather in a `key` and `value` column:

```{r}
native_range %<>% gather(
  key, value,
  native_range_1, native_range_2, native_range_3,
  na.rm = TRUE, # Also removes records for which there is no native_range_1
  convert = FALSE
)
```

Sumarize `value`

```{r}
native_range %>%
  group_by(value) %>%
  count()
```

Recode `probably the Americas` to `America`:

```{r}
native_range %<>% mutate(description = recode(value,
  "probably the Americas" = "America"))
```

Drop the `key` and `value` columns:

```{r}
native_range %<>% select(-key, -value)
```

Create a `type` field to indicate the type of description:

```{r}
native_range %<>% mutate(type = "native range")
```


### Degree of establishment

Here, we use the [invasion stage vocabulary from Blackburn et al. (2011)](http://doc.rero.ch/record/24725/files/bach_puf.pdf) to standardize this information.

```{r}
degree_of_establishment <- input_data
```

Summarize content

```{r}
degree_of_establishment %>%
  group_by(degree_of_establishment) %>%
  count()
```

Create `description`:

```{r}
degree_of_establishment %<>% mutate(description = degree_of_establishment)
```

Create `type`:

```{r}
degree_of_establishment %<>% mutate(type = "degree of establishment")
```

### Pathway of introduction

Here, we use the vocabulary proposed by [CBD standard](https://www.cbd.int/doc/meetings/sbstta/sbstta-18/official/sbstta-18-09-add1-en.pdf) to standardize this information.

```{r}
pathway <- input_data
```

Summarize content

```{r}
pathway %>%
  group_by(introduction_pathway) %>%
  count()
```

`pathway` contains multiple values (currently not more than 2), so we separate it in 2 columns:

```{r}
pathway %<>% separate(introduction_pathway, 
  into = c("pathway_1", "pathway_2"),
  sep = "\\s\\|\\s",
  remove = FALSE)
```

Gather in a `key` and `value` column:

```{r}
pathway %<>% gather(
  key, value,
  pathway_1, pathway_2,
  na.rm = TRUE, # Also removes records for which there is no native_range_1
  convert = FALSE
)
```

Add prefix `cbd_2014_pathway:`

```{r}
pathway %<>% mutate(mapped_value = paste ("cbd_2014_pathway", value, sep = ":"))
```

Sumarize `value`

```{r}
pathway %>%
  group_by(mapped_value) %>%
  count()
```

Generate `description`:

```{r}
pathway %<>% mutate(description = mapped_value) 
```


Drop the `key` and `value` columns:

```{r}
pathway %<>% select(-key, -value)
```


Create a `type` field to indicate the type of description:

```{r}
pathway %<>% mutate(type = "pathway")
```


### Union description

Union native range and degree of establishment:

```{r start_description_ext}
description_ext <- bind_rows(native_range, degree_of_establishment, pathway)
```

Map the data to [Taxon Description](http://rs.gbif.org/extension/gbif/1.0/description.xml):

#### taxonID

```{r}
description_ext %<>% mutate(dwc_taxonID = taxon_id)
```

#### description

```{r}
description_ext %<>% mutate(dwc_description = description)
```

#### type

```{r}
description_ext %<>% mutate(dwc_type = type)
```

#### language

```{r}
description_ext %<>% mutate(dwc_language = "en")
```

# Post-processing

Remove the original columns for each of the generated files:

```{r}
species_profile %<>% select(starts_with("dwc_")) 
description_ext %<>% select(starts_with("dwc_"))
```

Drop the `dwc_` prefix:

```{r}
colnames(species_profile) <- str_remove(colnames(species_profile), "dwc_")
colnames(description_ext) <- str_remove(colnames(description_ext), "dwc_")
```

Sort on `taxonID` to group description information per taxon:

```{r}
species_profile %<>% arrange(taxonID)
description_ext %<>% arrange(taxonID)
```



Preview species profile extension:

```{r}
species_profile %>% head(10)
```

Preview description extension:

```{r}
description_ext %>% head(10)
```

Save to CSV:

```{r}
write_csv(taxon, here("data", "processed", "taxon.csv"), na = "")
write_csv(distribution, here("data", "processed", "distribution.csv"), na = "")
write_csv(species_profile, here("data", "processed", "speciesprofile.csv"), na = "")
write_csv(description_ext, here("data", "processed", "description.csv"), na = "")
```


